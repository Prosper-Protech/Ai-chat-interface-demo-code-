<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Support ‚Äì SAMITECH</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"/>
<style>
:root {
    --accent:#6366f1;
    --bg-dark:#0b0b10;
    --bg-light:#f5f6fa;
    --panel-dark:rgba(20,20,30,.95);
    --panel-light:#ffffff;
    --text-dark:#fff;
    --text-light:#111;
    --user-bubble-dark:var(--accent);
    --ai-bubble-dark:#1c1c1e;
    --user-bubble-light:#6366f1;
    --ai-bubble-light:#e5e7eb;
}
* {
    box-sizing: border-box;
}
body {
    margin:0;
    font-family:Inter,system-ui;
    background:var(--bg-dark);
    transition:0.3s;
    height: 100vh;
    overflow-x: hidden;
}
body.light{background:var(--bg-light);}
#aiWidget{
    position:fixed;
    right:16px;
    bottom:16px;
    z-index:10000;
}
#aiBubble{
    width:60px;
    height:60px;
    border-radius:50%;
    background:linear-gradient(135deg,#6366f1,#8b5cf6);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    box-shadow:0 10px 30px rgba(99,102,241,.5);
    transition:transform 0.3s ease, opacity 0.3s ease;
    z-index:10001;
    border: 2px solid rgba(255,255,255,0.2);
}
#aiBubble:hover{
    transform:scale(1.1);
    box-shadow:0 15px 40px rgba(99,102,241,.7);
}
#aiBubble img{
    width:36px;
    height:36px;
    border-radius:50%;
    pointer-events: none;
}
#aiBox{
    width:90vw;
    max-width:400px;
    height:70vh;
    border-radius:22px;
    overflow:hidden;
    display:none;
    flex-direction:column;
    background:var(--panel-dark);
    color:var(--text-dark);
    backdrop-filter:blur(20px);
    -webkit-backdrop-filter: blur(20px);
    box-shadow:0 20px 50px rgba(0,0,0,.7);
    border:1px solid rgba(255,255,255,0.1);
    position:fixed;
    right:16px;
    bottom:80px;
    z-index:10002;
    opacity: 0;
    transform: translateY(20px) scale(0.95);
    transition: opacity 0.3s ease, transform 0.3s ease;
}
#aiBox.open {
    display: flex;
    opacity: 1;
    transform: translateY(0) scale(1);
}
body.light #aiBox{
    background:var(--panel-light);
    color:var(--text-light);
    border:1px solid rgba(0,0,0,0.1);
}
.ai-header{
    background:url('https://images.unsplash.com/photo-1518770660439-4636190af475') center/cover;
    height:90px;
    display:flex;
    flex-direction:column;
    justify-content:center;
    padding:10px;
    position:relative;
}
.ai-header h1{
    color:#fff;
    font-size:18px;
    font-weight:bold;
    margin:0;
    text-shadow:0 1px 3px rgba(0,0,0,0.5);
}
.ai-header h3{
    color:#d1d5db;
    font-size:12px;
    font-weight:400;
    margin:0;
    text-shadow:0 1px 2px rgba(0,0,0,0.5);
}
.ai-header .close, .ai-header .theme-toggle{
    position:absolute;
    top:10px;
    cursor:pointer;
    color:#fff;
    background:rgba(0,0,0,0.3);
    border-radius:50%;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:all 0.2s ease;
    z-index:10003;
}
.ai-header .close:hover, .ai-header .theme-toggle:hover{
    background:rgba(0,0,0,0.5);
    transform:scale(1.1);
}
.ai-header .close{right:10px;}
.ai-header .theme-toggle{right:40px;}
#messages{
    flex:1;
    overflow-y:auto;
    padding:12px;
    background:transparent;
    scrollbar-width:thin;
    scrollbar-color:var(--accent) transparent;
}
#messages::-webkit-scrollbar{
    width:6px;
}
#messages::-webkit-scrollbar-track{
    background:transparent;
}
#messages::-webkit-scrollbar-thumb{
    background:var(--accent);
    border-radius:3px;
}

/* Message Layout */
.msg{
    display:flex;
    margin-bottom:12px;
    position:relative;
    animation:fadeIn 0.3s ease;
}
@keyframes fadeIn{
    from{
        opacity:0;
        transform:translateY(10px);
    }
    to{
        opacity:1;
        transform:translateY(0);
    }
}

/* AI MESSAGE - LEFT SIDE */
.msg.ai{
    justify-content:flex-start;
}
.msg.ai .bubble{
    background:var(--ai-bubble-dark);
    color:#fff;
    border-radius:18px 18px 18px 6px;
    margin-left:0;
    margin-right:auto;
}
body.light .msg.ai .bubble{
    background:var(--ai-bubble-light);
    color:#111;
}

/* USER MESSAGE - RIGHT SIDE */
.msg.user{
    justify-content:flex-end;
}
.msg.user .bubble{
    background:var(--user-bubble-dark);
    color:#fff;
    border-radius:18px 18px 6px 18px;
    margin-left:auto;
    margin-right:0;
}
body.light .msg.user .bubble{
    background:var(--user-bubble-light);
    color:#fff;
}

.bubble{
    padding:10px 14px;
    max-width:75%;
    font-size:14px;
    line-height:1.4;
    position:relative;
    word-wrap:break-word;
    box-shadow:0 2px 5px rgba(0,0,0,0.1);
}
.avatar{
    width:36px;
    height:36px;
    border-radius:50%;
    object-fit:cover;
}

/* Avatar positioning */
.msg.ai .avatar{
    order:1;
    margin-right:10px;
}
.msg.user .avatar{
    order:2;
    margin-left:10px;
}

/* Message content container */
.msg-content{
    display:flex;
    flex-direction:column;
    max-width:calc(100% - 46px);
}
.msg.ai .msg-content{
    order:2;
    align-items:flex-start;
}
.msg.user .msg-content{
    order:1;
    align-items:flex-end;
}

.msg-tools{
    display:flex;
    gap:6px;
    font-size:12px;
    opacity:.6;
    margin-top:4px;
}
.msg-tools span{
    cursor:pointer;
    padding:2px 6px;
    border-radius:4px;
    transition:all 0.2s ease;
}
.msg-tools span:hover{
    opacity:1;
    background:rgba(255,255,255,0.1);
}

.ai-input{
    display:flex;
    gap:8px;
    padding:10px;
    background:rgba(0,0,0,.2);
    border-top:1px solid rgba(255,255,255,0.1);
}
body.light .ai-input{
    background:rgba(200,200,200,.2);
    border-top:1px solid rgba(0,0,0,0.1);
}
.ai-input textarea{
    flex:1;
    border-radius:30px;
    padding:8px 12px;
    background:rgba(255,255,255,.1);
    color:inherit;
    resize:none;
    border:none;
    outline:none;
    font-size:14px;
    transition:all 0.2s ease;
    font-family: inherit;
    min-height: 40px;
    max-height: 120px;
}
.ai-input textarea:focus{
    background:rgba(255,255,255,.15);
    box-shadow:0 0 0 2px rgba(99,102,241,0.3);
}
body.light .ai-input textarea{
    background:rgba(255,255,255,.5);
}
body.light .ai-input textarea:focus{
    background:rgba(255,255,255,.8);
}
.ai-input button{
    width:40px;
    height:40px;
    border-radius:50%;
    background:var(--accent);
    color:#fff;
    border:none;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    transition:all 0.2s ease;
    flex-shrink: 0;
}
.ai-input button:hover{
    transform:scale(1.1);
    box-shadow:0 5px 15px rgba(99,102,241,0.4);
}
.ai-input button:disabled{
    opacity:0.5;
    cursor:not-allowed;
    transform:none;
}
.typing{
    display:flex;
    gap:6px;
    padding:6px;
}
.wave{
    height:8px;
    width:8px;
    background:#999;
    border-radius:50%;
    animation:wave 1s infinite alternate;
}
.wave:nth-child(2){
    animation-delay:.2s;
}
.wave:nth-child(3){
    animation-delay:.4s;
}
@keyframes wave{
    0%,100%{
        transform:scaleY(0.4);
    }
    50%{
        transform:scaleY(1);
    }
}
.status-indicator{
    position:absolute;
    bottom:10px;
    left:10px;
    display:flex;
    align-items:center;
    gap:5px;
    font-size:10px;
    opacity:0.7;
    z-index:10003;
}
.status-dot{
    width:6px;
    height:6px;
    border-radius:50%;
}
.status-dot.connected{
    background:#10b981;
    animation:pulse 2s infinite;
}
.status-dot.connecting{
    background:#f59e0b;
    animation:pulse 1s infinite;
}
.status-dot.disconnected{
    background:#ef4444;
}
@keyframes pulse{
    0%,100%{
        opacity:1;
    }
    50%{
        opacity:0.5;
    }
}
@media(max-width:480px){
    #aiBox{
        width:95vw;
        height:75vh;
        border-radius:18px;
        right: 10px;
        bottom: 70px;
    }
    .bubble{
        max-width:80%;
    }
}
</style>
</head>
<body>
<div id="aiWidget">
 <div id="aiBubble" title="Open AI Assistant">
    <img src="https://cdn-icons-png.flaticon.com/512/4712/4712109.png" alt="AI Assistant" id="aiAvatar">
 </div>
 <div id="aiBox">
  <div class="ai-header">
   <h1>AI Support</h1>
   <h3>SAMITECH CORPORATION</h3>
   <span class="theme-toggle" id="themeToggle"><i class="fa fa-moon"></i></span>
   <span class="close" id="closeBtn"><i class="fa fa-xmark"></i></span>
  </div>
  <div id="messages"></div>
  <div class="ai-input">
   <textarea id="input" rows="1" placeholder="Ask me anything..."></textarea>
   <button id="sendBtn"><i class="fa fa-paper-plane"></i></button>
  </div>
  <div class="status-indicator">
   <div id="statusDot" class="status-dot disconnected"></div>
   <span id="statusText">Disconnected</span>
  </div>
 </div>
</div>

<script>
// ============================
// AI CHAT - VERCEL FIXED VERSION
// ============================

// Debug logging
console.log('üöÄ AI Chat Widget Loading...');

// Global variables
let open = false;
let ws = null;
let isProcessing = false;
let typingEl = null;
let currentChatId = 'chat_' + Date.now();
let currentAIResponse = null;
let responseComplete = true;
let conversationHistory = [];

// DOM elements - will be initialized after DOM loads
let box, messages, input, sendBtn, statusDot, statusText, aiBubble, closeBtn, themeToggle;

// Initialize everything when DOM is ready
function initializeChat() {
    console.log('üîÑ Initializing AI Chat Widget...');
    
    // Get DOM elements
    box = document.getElementById('aiBox');
    messages = document.getElementById('messages');
    input = document.getElementById('input');
    sendBtn = document.getElementById('sendBtn');
    statusDot = document.getElementById('statusDot');
    statusText = document.getElementById('statusText');
    aiBubble = document.getElementById('aiBubble');
    closeBtn = document.getElementById('closeBtn');
    themeToggle = document.getElementById('themeToggle');
    
    // Debug element existence
    console.log('üìã Elements found:', {
        box: !!box,
        messages: !!messages,
        input: !!input,
        sendBtn: !!sendBtn,
        statusDot: !!statusDot,
        statusText: !!statusText,
        aiBubble: !!aiBubble,
        closeBtn: !!closeBtn,
        themeToggle: !!themeToggle
    });
    
    // Add initial welcome message
    addMsg('ai', 'Hello! I\'m your AI Support Assistant from SAMITECH CORPORATION. How can I help you today?');
    conversationHistory.push({
        role: 'assistant',
        content: 'Hello! I\'m your AI Support Assistant from SAMITECH CORPORATION. How can I help you today?'
    });
    
    // Set up event listeners
    setupEventListeners();
    
    console.log('‚úÖ AI Chat Widget Initialized Successfully');
}

function setupEventListeners() {
    console.log('üîó Setting up event listeners...');
    
    // Bubble click - OPEN CHAT
    if (aiBubble) {
        aiBubble.addEventListener('click', function(e) {
            console.log('üéØ Bubble clicked! Opening chat...');
            e.stopPropagation();
            openChat();
        });
        
        // Add touch event for mobile
        aiBubble.addEventListener('touchstart', function(e) {
            console.log('üì± Touch event on bubble');
            e.preventDefault();
            openChat();
        }, { passive: false });
    } else {
        console.error('‚ùå aiBubble element not found!');
    }
    
    // Close button
    if (closeBtn) {
        closeBtn.addEventListener('click', function(e) {
            console.log('‚ùå Close button clicked');
            e.stopPropagation();
            closeChat();
        });
    }
    
    // Theme toggle
    if (themeToggle) {
        themeToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleTheme();
        });
    }
    
    // Send button
    if (sendBtn) {
        sendBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            sendMsg();
        });
    }
    
    // Input enter key
    if (input) {
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMsg();
            }
        });
        
        // Auto-resize
        input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });
    }
    
    // Close chat when clicking outside
    document.addEventListener('click', function(e) {
        if (open && box && !box.contains(e.target) && aiBubble && !aiBubble.contains(e.target)) {
            console.log('üëÜ Clicked outside, closing chat');
            closeChat();
        }
    });
    
    // Prevent closing when clicking inside chat
    if (box) {
        box.addEventListener('click', function(e) {
            e.stopPropagation();
        });
    }
    
    console.log('‚úÖ Event listeners set up');
}

function openChat() {
    console.log('üìñ Opening chat...');
    
    if (open) {
        console.log('‚ö†Ô∏è Chat already open');
        return;
    }
    
    open = true;
    
    // Show chat box with animation
    if (box) {
        box.classList.add('open');
        console.log('‚úÖ Chat box displayed');
        
        // Focus input after animation
        setTimeout(() => {
            if (input) {
                input.focus();
                console.log('üéØ Input focused');
            }
        }, 300);
    } else {
        console.error('‚ùå Chat box element not found!');
    }
    
    // Connect WebSocket
    connectWebSocket();
    
    console.log('üö™ Chat opened successfully');
}

function closeChat() {
    console.log('üìï Closing chat...');
    
    if (!open) {
        console.log('‚ö†Ô∏è Chat already closed');
        return;
    }
    
    open = false;
    
    // Hide chat box with animation
    if (box) {
        box.classList.remove('open');
        
        // Wait for animation then hide
        setTimeout(() => {
            if (box && !open) {
                box.style.display = 'none';
            }
        }, 300);
    }
    
    // Close WebSocket
    if (ws) {
        ws.close();
        ws = null;
        console.log('üîå WebSocket closed');
    }
    
    console.log('üö™ Chat closed successfully');
}

function toggleChat() {
    console.log('üîÑ Toggling chat state');
    if (open) {
        closeChat();
    } else {
        openChat();
    }
}

function toggleTheme() {
    document.body.classList.toggle('light');
    const icon = themeToggle.querySelector('i');
    if (icon) {
        icon.className = document.body.classList.contains('light') ? 'fa fa-sun' : 'fa fa-moon';
    }
    console.log('üé® Theme toggled');
}

function connectWebSocket() {
    console.log('üîó Connecting WebSocket...');
    
    if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('‚úÖ WebSocket already connected');
        updateStatus('Connected', 'connected');
        return;
    }
    
    updateStatus('Connecting...', 'connecting');
    
    try {
        ws = new WebSocket('wss://backend.buildpicoapps.com/api/chatbot/chat');
        
        ws.onopen = () => {
            console.log('‚úÖ WebSocket connected successfully');
            updateStatus('Connected', 'connected');
        };
        
        ws.onmessage = (event) => {
            handleWebSocketMessage(event.data);
        };
        
        ws.onclose = (event) => {
            console.log('üîå WebSocket closed');
            updateStatus('Disconnected', 'disconnected');
            ws = null;
            
            if (open) {
                setTimeout(() => {
                    connectWebSocket();
                }, 3000);
            }
        };
        
        ws.onerror = (error) => {
            console.error('‚ùå WebSocket error:', error);
            updateStatus('Connection Error', 'disconnected');
        };
        
    } catch (error) {
        console.error('‚ùå Failed to create WebSocket:', error);
        updateStatus('Failed to connect', 'disconnected');
    }
}

function updateStatus(text, status) {
    if (statusText && statusDot) {
        statusText.textContent = text;
        statusDot.className = 'status-dot ' + status;
    }
}

function handleWebSocketMessage(data) {
    if (!data || data.trim() === '') return;
    
    if (data === '[DONE]' || data === '[END]' || data === '[COMPLETE]') {
        console.log('‚úÖ Response complete');
        responseComplete = true;
        isProcessing = false;
        hideTyping();
        if (sendBtn) sendBtn.disabled = false;
        return;
    }
    
    try {
        if (data.startsWith('{') || data.startsWith('[')) {
            const jsonData = JSON.parse(data);
            
            if (jsonData.message || jsonData.response) {
                const fullResponse = jsonData.message || jsonData.response;
                hideTyping();
                addMsg('ai', fullResponse);
                
                conversationHistory.push({
                    role: 'assistant',
                    content: fullResponse
                });
                
                if (conversationHistory.length > 20) {
                    conversationHistory = conversationHistory.slice(-20);
                }
                
                responseComplete = true;
                isProcessing = false;
                if (sendBtn) sendBtn.disabled = false;
                return;
            }
        }
    } catch (e) {
        // Not JSON
    }
    
    if (responseComplete) {
        responseComplete = false;
        hideTyping();
        currentAIResponse = addMsg('ai', data);
    } else {
        if (currentAIResponse) {
            const bubble = currentAIResponse.querySelector('.bubble');
            const currentText = bubble.innerText || bubble.textContent;
            bubble.innerHTML = formatText(currentText + data);
            messages.scrollTop = messages.scrollHeight;
        }
    }
    
    const trimmedData = data.trim();
    if (trimmedData.endsWith('.') || trimmedData.endsWith('?') || trimmedData.endsWith('!')) {
        clearTimeout(window.responseCompleteTimer);
        window.responseCompleteTimer = setTimeout(() => {
            if (!responseComplete && currentAIResponse) {
                const fullResponse = currentAIResponse.querySelector('.bubble').innerText;
                conversationHistory.push({
                    role: 'assistant',
                    content: fullResponse
                });
                
                if (conversationHistory.length > 20) {
                    conversationHistory = conversationHistory.slice(-20);
                }
                
                responseComplete = true;
                isProcessing = false;
                hideTyping();
                if (sendBtn) sendBtn.disabled = false;
            }
        }, 1500);
    }
}

function sendMsg() {
    const text = input.value.trim();
    if (!text || isProcessing || !input) return;
    
    responseComplete = true;
    currentAIResponse = null;
    
    addMsg('user', text);
    input.value = '';
    input.style.height = 'auto';
    
    conversationHistory.push({
        role: 'user',
        content: text
    });
    
    if (conversationHistory.length > 20) {
        conversationHistory = conversationHistory.slice(-20);
    }
    
    isProcessing = true;
    if (sendBtn) sendBtn.disabled = true;
    
    showTyping();
    
    if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.log('üîå WebSocket not ready');
        connectWebSocket();
        
        setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                sendMessageToAI(text);
            } else {
                hideTyping();
                addMsg('ai', "I'm connecting... Please wait a moment.");
       style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            box.style.display = 'none';
        }, 300);
        
        // Close WebSocket when chat is closed
        if (ws) {
            ws.close();
            ws = null;
        }
    }
    
    // Force a reflow to ensure display changes
    box.offsetHeight;
}

function toggleTheme() {
    document.body.classList.toggle('light');
    const icon = document.querySelector('.theme-toggle i');
    icon.className = document.body.classList.contains('light') ? 'fa fa-sun' : 'fa fa-moon';
}

function connectWebSocket() {
    // If already connected, return
    if (ws && ws.readyState === WebSocket.OPEN) {
        updateStatus('Connected', 'connected');
        return;
    }
    
    updateStatus('Connecting...', 'connecting');
    
    try {
        // Create WebSocket connection
        ws = new WebSocket('wss://backend.buildpicoapps.com/api/chatbot/chat');
        
        ws.onopen = () => {
            console.log("‚úÖ WebSocket connected successfully");
            updateStatus('Connected', 'connected');
            
            // Show connection message if no messages yet
            if (messages.children.length <= 1) {
                setTimeout(() => {
                    addMsg('ai', 'AI Support is now online. I remember our previous conversation and can continue from where we left off.');
                }, 300);
            }
        };
        
        ws.onmessage = (event) => {
            handleWebSocketMessage(event.data);
        };
        
        ws.onclose = (event) => {
            console.log("üîå WebSocket closed");
            updateStatus('Disconnected', 'disconnected');
            ws = null;
            
            // Only auto-reconnect if chat is still open
            if (open) {
                setTimeout(() => {
                    connectWebSocket();
                }, 3000);
            }
        };
        
        ws.onerror = (error) => {
            console.error("‚ùå WebSocket error:", error);
            updateStatus('Connection Error', 'disconnected');
            
            // Fallback: Show offline message
            if (messages.children.length <= 1 && open) {
                setTimeout(() => {
                    addMsg('ai', '‚ö†Ô∏è Connection issues detected. Working in offline mode. Some features may be limited.');
                }, 500);
            }
        };
        
    } catch (error) {
        console.error("‚ùå Failed to create WebSocket:", error);
        updateStatus('Failed to connect', 'disconnected');
        
        // Show fallback message
        if (open && messages.children.length <= 1) {
            setTimeout(() => {
                addMsg('ai', '‚ö†Ô∏è Using offline mode. For full AI capabilities, please check your internet connection.');
            }, 500);
        }
    }
}

function updateStatus(text, status) {
    if (statusText && statusDot) {
        statusText.textContent = text;
        statusDot.className = 'status-dot ' + status;
    }
}

function handleWebSocketMessage(data) {
    console.log("üì• Received data:", typeof data, data.length);
    
    if (!data || data.trim() === '') return;
    
    // Check for completion signals
    if (data === '[DONE]' || data === '[END]' || data === '[COMPLETE]') {
        console.log("‚úÖ Response complete");
        
        responseComplete = true;
        isProcessing = false;
        hideTyping();
        if (sendBtn) sendBtn.disabled = false;
        
        // Scroll to bottom
        setTimeout(() => {
            if (messages) messages.scrollTop = messages.scrollHeight;
        }, 100);
        
        return;
    }
    
    // Try to parse as JSON
    try {
        if (data.startsWith('{') || data.startsWith('[')) {
            const jsonData = JSON.parse(data);
            console.log("üì¶ JSON response:", jsonData);
            
            if (jsonData.message || jsonData.response) {
                const fullResponse = jsonData.message || jsonData.response;
                
                hideTyping();
                addMsg('ai', fullResponse);
                
                // Add to conversation history
                conversationHistory.push({
                    role: 'assistant',
                    content: fullResponse
                });
                
                // Limit history size
                if (conversationHistory.length > 20) {
                    conversationHistory = conversationHistory.slice(-20);
                }
                
                responseComplete = true;
                isProcessing = false;
                if (sendBtn) sendBtn.disabled = false;
                
                return;
            }
        }
    } catch (e) {
        // Not JSON, continue as text stream
    }
    
    // Handle streaming text
    if (responseComplete) {
        responseComplete = false;
        hideTyping();
        currentAIResponse = addMsg('ai', data);
    } else {
        if (currentAIResponse) {
            const bubble = currentAIResponse.querySelector('.bubble');
            const currentText = bubble.innerText || bubble.textContent;
            bubble.innerHTML = formatText(currentText + data);
            
            // Scroll to bottom
            if (messages) messages.scrollTop = messages.scrollHeight;
        }
    }
    
    // Auto-detect response completion
    const trimmedData = data.trim();
    if (trimmedData.endsWith('.') || trimmedData.endsWith('?') || trimmedData.endsWith('!')) {
        clearTimeout(window.responseCompleteTimer);
        window.responseCompleteTimer = setTimeout(() => {
            if (!responseComplete && currentAIResponse) {
                const fullResponse = currentAIResponse.querySelector('.bubble').innerText || 
                                     currentAIResponse.querySelector('.bubble').textContent;
                
                // Add to conversation history
                conversationHistory.push({
                    role: 'assistant',
                    content: fullResponse
                });
                
                // Limit history
                if (conversationHistory.length > 20) {
                    conversationHistory = conversationHistory.slice(-20);
                }
                
                responseComplete = true;
                isProcessing = false;
                hideTyping();
                if (sendBtn) sendBtn.disabled = false;
            }
        }, 1500);
    }
}

function sendMsg() {
    const text = input.value.trim();
    if (!text || isProcessing || !input) return;
    
    responseComplete = true;
    currentAIResponse = null;
    
    // Add user message
    addMsg('user', text);
    input.value = '';
    input.style.height = 'auto';
    
    // Add to conversation history
    conversationHistory.push({
        role: 'user',
        content: text
    });
    
    // Limit history
    if (conversationHistory.length > 20) {
        conversationHistory = conversationHistory.slice(-20);
    }
    
    isProcessing = true;
    if (sendBtn) sendBtn.disabled = true;
    
    showTyping();
    
    // Check WebSocket connection
    if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.log("üîå WebSocket not ready, attempting connection...");
        connectWebSocket();
        
        setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                sendMessageToAI(text);
            } else {
                // Fallback response
                hideTyping();
                addMsg('ai', "I'm having connection issues. Based on our conversation, I remember you asked about: \"" + text + "\"\n\nPlease try again in a moment or check your connection.");
                
                // Add fallback to history
                const fallbackMsg = "Connection issues - user asked about: " + text;
                conversationHistory.push({
                    role: 'assistant',
                    content: fallbackMsg
                });
                
                isProcessing = false;
                if (sendBtn) sendBtn.disabled = false;
            }
        }, 1500);
    } else {
        sendMessageToAI(text);
    }
}

function sendMessageToAI(text) {
    try {
        // Build conversation context
        let conversationContext = "";
        conversationHistory.forEach((msg, index) => {
            const role = msg.role === 'user' ? 'User' : 'Assistant';
            conversationContext += `${role}: ${msg.content}\n\n`;
        });
        
        const systemPrompt = `You are AI Support from SAMITECH CORPORATION.

CONVERSATION HISTORY:
${conversationContext}

IMPORTANT: Remember our entire conversation and continue naturally from previous topics.
If user asks follow-up questions, reference previous points when relevant.

User's latest message: ${text}

Provide a helpful, context-aware response:`;

        const payload = {
            chatId: currentChatId,
            appId: 'word-almost',
            systemPrompt: systemPrompt,
            message: text,
            stream: true
        };

        console.log("üì§ Sending message to AI");
        ws.send(JSON.stringify(payload));

        // Set timeout for response
        clearTimeout(window.responseTimeout);
        window.responseTimeout = setTimeout(() => {
            if (isProcessing && currentAIResponse) {
                console.log("‚è∞ Response timeout");
                const bubble = currentAIResponse.querySelector('.bubble');
                if (bubble) {
                    bubble.innerHTML = formatText((bubble.innerText || bubble.textContent) + "\n\n*[Response may be incomplete]*");
                }
                hideTyping();
                isProcessing = false;
                responseComplete = true;
                if (sendBtn) sendBtn.disabled = false;
            }
        }, 25000);

    } catch (error) {
        console.error("Error sending message:", error);
     .ai-header .theme-toggle{right:40px;}
#messages{flex:1;overflow-y:auto;padding:12px;background:transparent;scrollbar-width:thin;scrollbar-color:var(--accent) transparent;}
#messages::-webkit-scrollbar{width:6px;}
#messages::-webkit-scrollbar-track{background:transparent;}
#messages::-webkit-scrollbar-thumb{background:var(--accent);border-radius:3px;}

/* Message Layout */
.msg{display:flex;margin-bottom:12px;position:relative;animation:fadeIn 0.3s ease;}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px);}to{opacity:1;transform:translateY(0);}}

/* AI MESSAGE - LEFT SIDE */
.msg.ai{justify-content:flex-start;}
.msg.ai .bubble{background:var(--ai-bubble-dark);color:#fff;border-radius:18px 18px 18px 6px;margin-left:0;margin-right:auto;}
body.light .msg.ai .bubble{background:var(--ai-bubble-light);color:#111;}

/* USER MESSAGE - RIGHT SIDE */
.msg.user{justify-content:flex-end;}
.msg.user .bubble{background:var(--user-bubble-dark);color:#fff;border-radius:18px 18px 6px 18px;margin-left:auto;margin-right:0;}
body.light .msg.user .bubble{background:var(--user-bubble-light);color:#fff;}

.bubble{padding:10px 14px;max-width:75%;font-size:14px;line-height:1.4;position:relative;word-wrap:break-word;box-shadow:0 2px 5px rgba(0,0,0,0.1);}
.avatar{width:36px;height:36px;border-radius:50%;object-fit:cover;}

/* Avatar positioning */
.msg.ai .avatar{order:1;margin-right:10px;}
.msg.user .avatar{order:2;margin-left:10px;}

/* Message content container */
.msg-content{display:flex;flex-direction:column;max-width:calc(100% - 46px);}
.msg.ai .msg-content{order:2;align-items:flex-start;}
.msg.user .msg-content{order:1;align-items:flex-end;}

.msg-tools{display:flex;gap:6px;font-size:12px;opacity:.6;margin-top:4px;}
.msg-tools span{cursor:pointer;padding:2px 6px;border-radius:4px;transition:all 0.2s ease;}
.msg-tools span:hover{opacity:1;background:rgba(255,255,255,0.1);}

.ai-input{display:flex;gap:8px;padding:10px;background:rgba(0,0,0,.2);border-top:1px solid rgba(255,255,255,0.1);}
body.light .ai-input{background:rgba(200,200,200,.2);border-top:1px solid rgba(0,0,0,0.1);}
.ai-input textarea{flex:1;border-radius:30px;padding:8px 12px;background:rgba(255,255,255,.1);color:inherit;resize:none;border:none;outline:none;font-size:14px;transition:all 0.2s ease;}
.ai-input textarea:focus{background:rgba(255,255,255,.15);box-shadow:0 0 0 2px rgba(99,102,241,0.3);}
body.light .ai-input textarea{background:rgba(255,255,255,.5);}
body.light .ai-input textarea:focus{background:rgba(255,255,255,.8);}
.ai-input button{width:40px;height:40px;border-radius:50%;background:var(--accent);color:#fff;border:none;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all 0.2s ease;}
.ai-input button:hover{transform:scale(1.1);box-shadow:0 5px 15px rgba(99,102,241,0.4);}
.ai-input button:disabled{opacity:0.5;cursor:not-allowed;transform:none;}
.typing{display:flex;gap:6px;padding:6px;}
.wave{height:8px;width:8px;background:#999;border-radius:50%;animation:wave 1s infinite alternate;}
.wave:nth-child(2){animation-delay:.2s;}
.wave:nth-child(3){animation-delay:.4s;}
@keyframes wave{0%,100%{transform:scaleY(0.4);}50%{transform:scaleY(1);}}
.status-indicator{position:absolute;bottom:10px;left:10px;display:flex;align-items:center;gap:5px;font-size:10px;opacity:0.7;}
.status-dot{width:6px;height:6px;border-radius:50%;}
.status-dot.connected{background:#10b981;animation:pulse 2s infinite;}
.status-dot.connecting{background:#f59e0b;animation:pulse 1s infinite;}
.status-dot.disconnected{background:#ef4444;}
@keyframes pulse{0%,100%{opacity:1;}50%{opacity:0.5;}}
@media(max-width:480px){#aiBox{width:95vw;height:75vh;border-radius:18px;} .bubble{max-width:80%;}}
</style>
</head>
<body>
<div id="aiWidget">
 <div id="aiBubble"><img src="https://cdn-icons-png.flaticon.com/512/4712/4712109.png"></div>
 <div id="aiBox">
  <div class="ai-header">
   <h1>AI Support</h1>
   <h3>SAMITECH CORPORATION</h3>
   <span class="theme-toggle" onclick="toggleTheme()"><i class="fa fa-moon"></i></span>
   <span class="close" onclick="toggleChat()"><i class="fa fa-xmark"></i></span>
  </div>
  <div id="messages"></div>
  <div class="ai-input">
   <textarea id="input" rows="1" placeholder="Ask me anything..."></textarea>
   <button id="sendBtn" onclick="sendMsg()"><i class="fa fa-paper-plane"></i></button>
  </div>
  <div class="status-indicator">
   <div id="statusDot" class="status-dot disconnected"></div>
   <span id="statusText">Disconnected</span>
  </div>
 </div>
</div>

<script>
// ============================
// AI CHAT WITH CONVERSATION MEMORY
// ============================

let open = false;
let ws = null;
let isProcessing = false;
let typingEl = null;
let currentChatId = 'chat_' + Date.now();
let currentAIResponse = null;
let responseComplete = true;

// Conversation memory - stores the last 10 exchanges
let conversationHistory = [];

const box = document.getElementById('aiBox');
const messages = document.getElementById('messages');
const input = document.getElementById('input');
const sendBtn = document.getElementById('sendBtn');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');

// Initialize with a welcome message
window.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        addMsg('ai', 'Hello! I\'m your AI Support Assistant from SAMITECH CORPORATION. I remember our conversation and can continue discussions. How can I help you today?');
        // Add welcome message to history
        conversationHistory.push({
            role: 'assistant',
            content: 'Hello! I\'m your AI Support Assistant from SAMITECH CORPORATION. I remember our conversation and can continue discussions. How can I help you today?'
        });
    }, 500);
});

document.getElementById('aiBubble').onclick = toggleChat;

function toggleChat() {
    open = !open;
    box.style.display = open ? 'flex' : 'none';
    if (open) {
        connectWebSocket();
        input.focus();
    } else {
        if (ws) {
            ws.close();
            ws = null;
        }
    }
}

function toggleTheme() {
    document.body.classList.toggle('light');
    const icon = document.querySelector('.theme-toggle i');
    icon.className = document.body.classList.contains('light') ? 'fa fa-sun' : 'fa fa-moon';
}

function connectWebSocket() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        updateStatus('Connected', 'connected');
        return;
    }
    
    updateStatus('Connecting...', 'connecting');
    
    try {
        ws = new WebSocket('wss://backend.buildpicoapps.com/api/chatbot/chat');
        
        ws.onopen = () => {
            console.log("‚úÖ WebSocket connected successfully");
            updateStatus('Connected', 'connected');
            
            if (messages.children.length <= 1) {
                setTimeout(() => {
                    addMsg('ai', 'AI Support is now online. I remember our previous conversation and can continue from where we left off.');
                }, 300);
            }
        };
        
        ws.onmessage = (event) => {
            handleWebSocketMessage(event.data);
        };
        
        ws.onclose = (event) => {
            console.log("üîå WebSocket closed");
            updateStatus('Disconnected', 'disconnected');
            ws = null;
            
            if (open) {
                setTimeout(() => {
                    connectWebSocket();
                }, 2000);
            }
        };
        
        ws.onerror = (error) => {
            console.error("‚ùå WebSocket error:", error);
            updateStatus('Connection Error', 'disconnected');
        };
    } catch (error) {
        console.error("‚ùå Failed to create WebSocket:", error);
        updateStatus('Failed to connect', 'disconnected');
        
        setTimeout(() => {
            if (messages.children.length <= 1) {
                addMsg('ai', '‚ö†Ô∏è Using offline mode. For full AI capabilities, please check your internet connection.');
            }
        }, 500);
    }
}

function updateStatus(text, status) {
    statusText.textContent = text;
    statusDot.className = 'status-dot ' + status;
}

function handleWebSocketMessage(data) {
    console.log("üì• Raw data:", data);
    
    if (!data || data.trim() === '') return;
    
    if (data === '[DONE]' || data === '[END]' || data === '[COMPLETE]') {
        console.log("‚úÖ Response complete signal received");
        
        responseComplete = true;
        isProcessing = false;
        
        hideTyping();
        
        sendBtn.disabled = false;
        
        messages.scrollTop = messages.scrollHeight;
        return;
    }
    
    try {
        if (data.startsWith('{') || data.startsWith('[')) {
            const jsonData = JSON.parse(data);
            console.log("üì¶ Parsed JSON response:", jsonData);
            
            if (jsonData.message || jsonData.response || jsonData.choices?.[0]?.text) {
                const fullResponse = jsonData.message || jsonData.response || jsonData.choices[0].text;
                
                hideTyping();
                
                addMsg('ai', fullResponse);
                
                // Add AI response to conversation history
                conversationHistory.push({
                    role: 'assistant',
                    content: fullResponse
                });
                
                // Keep only last 20 messages (10 exchanges) to avoid token limits
                if (conversationHistory.length > 20) {
                    conversationHistory = conversationHistory.slice(-20);
                }
                
                responseComplete = true;
                isProcessing = false;
                sendBtn.disabled = false;
                
                return;
            }
        }
    } catch (e) {
        // Not JSON, continue as text stream
    }
    
    if (responseComplete) {
        responseComplete = false;
        hideTyping();
        
        currentAIResponse = addMsg('ai', data);
    } else {
        if (currentAIResponse) {
            const bubble = currentAIResponse.querySelector('.bubble');
            const currentText = bubble.innerText || bubble.textContent;
            bubble.innerHTML = formatText(currentText + data);
            
            messages.scrollTop = messages.scrollHeight;
        }
    }
    
    const trimmedData = data.trim();
    if (trimmedData.endsWith('.') || trimmedData.endsWith('?') || trimmedData.endsWith('!') || 
        trimmedData.endsWith('```') || trimmedData.endsWith('**')) {
        
        clearTimeout(window.responseCompleteTimer);
        window.responseCompleteTimer = setTimeout(() => {
            if (!responseComplete) {
                console.log("‚è±Ô∏è Auto-detected response completion");
                
                // Get the full AI response from the bubble
                if (currentAIResponse) {
                    const fullResponse = currentAIResponse.querySelector('.bubble').innerText || 
                                         currentAIResponse.querySelector('.bubble').textContent;
                    
                    // Add AI response to conversation history
                    conversationHistory.push({
                        role: 'assistant',
                        content: fullResponse
                    });
                    
                    // Keep only last 20 messages
                    if (conversationHistory.length > 20) {
                        conversationHistory = conversationHistory.slice(-20);
                    }
                }
                
                responseComplete = true;
                isProcessing = false;
                hideTyping();
                sendBtn.disabled = false;
                
                setTimeout(() => {
                    messages.scrollTop = messages.scrollHeight;
                }, 100);
            }
        }, 1000);
    }
}

function sendMsg() {
    const text = input.value.trim();
    if (!text || isProcessing) return;
    
    responseComplete = true;
    currentAIResponse = null;
    
    // Add user message to UI (RIGHT side)
    addMsg('user', text);
    input.value = '';
    input.style.height = 'auto';
    
    // Add user message to conversation history
    conversationHistory.push({
        role: 'user',
        content: text
    });
    
    // Keep only last 20 messages (10 exchanges)
    if (conversationHistory.length > 20) {
        conversationHistory = conversationHistory.slice(-20);
    }
    
    console.log("üíæ Conversation history:", conversationHistory);
    
    isProcessing = true;
    sendBtn.disabled = true;
    
    showTyping();
    
    if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.log("üîå WebSocket not connected, connecting...");
        connectWebSocket();
        
        setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                sendMessageToAI(text);
            } else {
                hideTyping();
                addMsg('ai', "I'm having trouble connecting. I remember our conversation and will continue once connected.");
                isProcessing = false;
                sendBtn.disabled = false;
            }
        }, 1000);
    } else {
        sendMessageToAI(text);
    }
}

function sendMessageToAI(text) {
    try {
        // Build context from conversation history
        let conversationContext = "";
        
        // Format the conversation history for context
        conversationHistory.forEach((msg, index) => {
            const role = msg.role === 'user' ? 'User' : 'Assistant';
            conversationContext += `${role}: ${msg.content}\n\n`;
        });
        
        const systemPrompt = `You are AI Support from SAMITECH CORPORATION - a professional technology solutions company.

IMPORTANT CONTEXT - OUR CONVERSATION HISTORY:
${conversationContext}

IMPORTANT: You MUST remember our entire conversation above and continue from where we left off.
If the user refers to something previously discussed, use that context to provide relevant answers.

Response Guidelines:
1. Remember ALL previous messages in this conversation
2. If user asks follow-up questions, continue from previous discussion
3. Reference previous points when relevant
4. Maintain context and continuity
5. Be thorough and comprehensive
6. Use markdown formatting for readability
7. End with a summary or next steps

Current user message: ${text}

Provide a complete, context-aware response that continues our conversation:`;

        const payload = {
            chatId: currentChatId,
            appId: 'word-almost',
            systemPrompt: systemPrompt,
            message: text,
            stream: true
        };

        console.log("üì§ Sending to AI with conversation context");
        ws.send(JSON.stringify(payload));

        clearTimeout(window.responseTimeout);
        window.responseTimeout = setTimeout(() => {
            if (isProcessing) {
                console.log("‚è∞ Response timeout - forcing completion");
                
                if (currentAIResponse) {
                    const bubble = currentAIResponse.querySelector('.bubble');
                    bubble.innerHTML = formatText((bubble.innerText || bubble.textContent) + "\n\n*[Response truncated due to timeout]*");
                }
                
                hideTyping();
                isProcessing = false;
                responseComplete = true;
                sendBtn.disabled = false;
                messages.scrollTop = messages.scrollHeight;
            }
        }, 30000);

    } catch (error) {
        console.error("Error sending message:", error);
        hideTyping();
        
        // Fallback with memory
        const lastUserMsg = conversationHistory.filter(msg => msg.role === 'user').slice(-1)[0]?.content || text;
        const lastAIMsg = conversationHistory.filter(msg => msg.role === 'assistant').slice(-1)[0]?.content || '';
        
        const fallback = `I remember we were discussing: "${lastUserMsg}"\n\nBased on our conversation history, here's my response:\n\nThis appears to be a follow-up question. For detailed, context-aware assistance, please ensure you have a stable internet connection.`;
        
        addMsg('ai', fallback);
        
        // Add to history even in fallback
        conversationHistory.push({
            role: 'assistant',
            content: fallback
        });
        
        isProcessing = false;
        sendBtn.disabled = false;
    }
}

function addMsg(type, text) {
    const div = document.createElement('div');
    div.className = 'msg ' + type;
    
    const avatarSrc = type === 'ai' 
        ? 'https://cdn-icons-png.flaticon.com/512/4712/4712109.png'
        : 'https://cdn-icons-png.flaticon.com/512/3135/3135715.png';
    
    const time = new Date().toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
    });
    
    const formattedText = formatText(text);
    
    div.innerHTML = `
        ${type === 'ai' ? `<img class="avatar" src="${avatarSrc}" alt="AI avatar">` : ''}
        <div class="msg-content">
            <div class="bubble">${formattedText}</div>
            <div class="msg-tools">
                <span onclick="copyMsg(this)" title="Copy message"><i class="fa fa-copy"></i></span>
                <span onclick="editMsg(this)" title="Edit message"><i class="fa fa-pen"></i></span>
                <span onclick="deleteMsg(this)" title="Delete message"><i class="fa fa-trash"/ Skip empty messages
    if (!data || data.trim() === '') return;
    
    // Check for completion signal
    if (data === '[DONE]' || data === '[END]' || data === '[COMPLETE]') {
        console.log("‚úÖ Response complete signal received");
        
        // Mark response as complete
        responseComplete = true;
        isProcessing = false;
        
        // Remove typing indicator
        hideTyping();
        
        // Re-enable send button
        sendBtn.disabled = false;
        
        // Ensure scroll is at bottom
        messages.scrollTop = messages.scrollHeight;
        return;
    }
    
    // Try to parse as JSON first
    try {
        if (data.startsWith('{') || data.startsWith('[')) {
            const jsonData = JSON.parse(data);
            console.log("üì¶ Parsed JSON response:", jsonData);
            
            if (jsonData.message || jsonData.response || jsonData.choices?.[0]?.text) {
                const fullResponse = jsonData.message || jsonData.response || jsonData.choices[0].text;
                
                // Hide typing indicator
                hideTyping();
                
                // Add the complete response
                addMsg('ai', fullResponse);
                
                // Mark as complete
                responseComplete = true;
                isProcessing = false;
                sendBtn.disabled = false;
                
                return;
            }
        }
    } catch (e) {
        // Not JSON, continue as text stream
    }
    
    // Handle streaming text response
    if (responseComplete) {
        // Start new response
        responseComplete = false;
        hideTyping(); // Remove any existing typing indicator
        
        // Create new AI message
        currentAIResponse = addMsg('ai', data);
    } else {
        // Append to existing response
        if (currentAIResponse) {
            const bubble = currentAIResponse.querySelector('.bubble');
            const currentText = bubble.innerText || bubble.textContent;
            bubble.innerHTML = formatText(currentText + data);
            
            // Auto-scroll to bottom
            messages.scrollTop = messages.scrollHeight;
        }
    }
    
    // Auto-detect if response seems complete (based on punctuation)
    const trimmedData = data.trim();
    if (trimmedData.endsWith('.') || trimmedData.endsWith('?') || trimmedData.endsWith('!') || 
        trimmedData.endsWith('```') || trimmedData.endsWith('**')) {
        
        // Set a timer to mark as complete (allows for more text to come)
        clearTimeout(window.responseCompleteTimer);
        window.responseCompleteTimer = setTimeout(() => {
            if (!responseComplete) {
                console.log("‚è±Ô∏è Auto-detected response completion");
                responseComplete = true;
                isProcessing = false;
                hideTyping();
                sendBtn.disabled = false;
                
                // Ensure scroll is at bottom
                setTimeout(() => {
                    messages.scrollTop = messages.scrollHeight;
                }, 100);
            }
        }, 1000); // Wait 1 second for more text
    }
}

function sendMsg() {
    const text = input.value.trim();
    if (!text || isProcessing) return;
    
    // Reset state
    responseComplete = true;
    currentAIResponse = null;
    
    // Add user message
    addMsg('user', text);
    input.value = '';
    input.style.height = 'auto';
    
    // Disable send button and set processing
    isProcessing = true;
    sendBtn.disabled = true;
    
    // Show typing indicator
    showTyping();
    
    // Check WebSocket connection
    if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.log("üîå WebSocket not connected, connecting...");
        connectWebSocket();
        
        // Wait for connection then send
        setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                sendMessageToAI(text);
            } else {
                // Connection failed - show fallback
                hideTyping();
                addMsg('ai', "I'm having trouble connecting. Here's what I can tell you about: \"" + text + "\"\n\nPlease try again in a moment or check your connection.");
                isProcessing = false;
                sendBtn.disabled = false;
            }
        }, 1000);
    } else {
        sendMessageToAI(text);
    }
}

function sendMessageToAI(text) {
    try {
        const systemPrompt = `You are AI Support from SAMITECH CORPORATION - a professional technology solutions company.

IMPORTANT: ALWAYS provide COMPLETE, DETAILED responses. Your responses should be:
1. Thorough and comprehensive
2. Well-structured with clear sections
3. Include practical examples when relevant
4. End with a summary or actionable next steps
5. Use markdown formatting for readability

User's question: ${text}

Provide a complete, helpful response:`;

        const payload = {
            chatId: currentChatId,
            appId: 'word-almost',
            systemPrompt: systemPrompt,
            message: text,
            stream: true
        };

        console.log("üì§ Sending to AI:", text);
        ws.send(JSON.stringify(payload));

        // Set response timeout (30 seconds)
        clearTimeout(window.responseTimeout);
        window.responseTimeout = setTimeout(() => {
            if (isProcessing) {
                console.log("‚è∞ Response timeout - forcing completion");
                
                if (currentAIResponse) {
                    const bubble = currentAIResponse.querySelector('.bubble');
                    bubble.innerHTML = formatText((bubble.innerText || bubble.textContent) + "\n\n*[Response truncated due to timeout]*");
                }
                
                hideTyping();
                isProcessing = false;
                responseComplete = true;
                sendBtn.disabled = false;
                messages.scrollTop = messages.scrollHeight;
            }
        }, 30000);

    } catch (error) {
        console.error("Error sending message:", error);
        hideTyping();
        
        // Fallback response based on question type
        const fallbackResponses = {
            'tech': `Regarding your technical question about "${text}", here's what I can tell you:\n\n**Common Solutions:**\n1. Check documentation and error logs\n2. Verify configuration settings\n3. Test in isolation to identify the issue\n4. Consult community forums for similar cases\n\n**Recommended Next Steps:**\n- Gather more specific error details\n- Review recent changes to the system\n- Consider reaching out to official support channels\n\n*Note: For complete AI assistance, please ensure you have a stable internet connection.*`,
            'general': `I understand you're asking about "${text}". Here's a general overview:\n\nThis topic typically involves several key aspects that should be considered. Based on common best practices, I recommend:\n\n1. Starting with basic research and understanding\n2. Consulting official documentation when available\n3. Considering practical implementation steps\n4. Testing and validating any proposed solutions\n\nFor a more detailed, specific response, please try again with a stable connection to our AI service.`
        };
        
        const responseType = text.toLowerCase().includes('error') || text.toLowerCase().includes('bug') || 
                           text.toLowerCase().includes('fix') || text.toLowerCase().includes('technical') ? 'tech' : 'general';
        
        addMsg('ai', fallbackResponses[responseType]);
        isProcessing = false;
        sendBtn.disabled = false;
    }
}

function addMsg(type, text) {
    const div = document.createElement('div');
    div.className = 'msg ' + type;
    
    const avatarSrc = type === 'ai' 
        ? 'https://cdn-icons-png.flaticon.com/512/4712/4712109.png'
        : 'https://cdn-icons-png.flaticon.com/512/3135/3135715.png';
    
    const time = new Date().toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
    });
    
    // Format text with proper markdown
    const formattedText = formatText(text);
    
    div.innerHTML = `
        <img class="avatar" src="${avatarSrc}" alt="${type} avatar">
        <div style="flex:1;">
            <div class="bubble">${formattedText}</div>
            <div class="msg-tools">
                <span onclick="copyMsg(this)" title="Copy message"><i class="fa fa-copy"></i></span>
                <span onclick="editMsg(this)" title="Edit message"><i class="fa fa-pen"></i></span>
                <span onclick="deleteMsg(this)" title="Delete message"><i class="fa fa-trash"></i></span>
                <span onclick="shareMsg(this)" title="Share message"><i class="fa fa-share-nodes"></i></span>
                <span style="margin-left:5px;font-size:10px;color:#888;">${time}</span>
            </div>
        </div>
    `;
    
    messages.appendChild(div);
    messages.scrollTop = messages.scrollHeight;
    
    // If this is an AI response, store reference
    if (type === 'ai') {
        currentAIResponse = div;
    }
    
    return div;
}

function formatText(text) {
    if (!text) return '';
    
    // Convert to string
    let formatted = String(text);
    
    // Preserve line breaks for code blocks first
    const codeBlockRegex = /```([\s\S]*?)```/g;
    const codeBlocks = [];
    let match;
    let i = 0;
    
    while ((match = codeBlockRegex.exec(formatted)) !== null) {
        codeBlocks.push(match[0]);
        formatted = formatted.replace(match[0], `__CODE_BLOCK_${i}__`);
        i++;
    }
    
    // Replace code blocks back after processing
    formatted = formatted
        // Headers
        .replace(/^###\s+(.*)$/gm, '<h3 style="font-size: 1.1em; font-weight: 600; margin: 10px 0 5px;">$1</h3>')
        .replace(/^##\s+(.*)$/gm, '<h2 style="font-size: 1.2em; font-weight: 700;="sendMsg()"><i class="fa fa-paper-plane"></i></button>
  </div>
 </div>
</div>

<script>
let open=false, ws=null, aiMsgEl=null, allowSave=true;

const aiBox=document.getElementById('aiBox'),
      messages=document.getElementById('messages'),
      aiBubble=document.getElementById('aiBubble'),
      input=document.getElementById('input'),
      status=document.getElementById('status');

document.addEventListener('DOMContentLoaded',()=>{ loadChat(); });

aiBubble.onclick=toggleChat;

function toggleChat(){
 open=!open;
 aiBox.style.display=open?'flex':'none';
 if(open) connect();
}

function toggleTheme(){document.body.classList.toggle('light');}

// ===== WebSocket =====
function connect(){
 if(ws && ws.readyState===WebSocket.OPEN) return;
 ws=new WebSocket('wss://backend.buildpicoapps.com/api/chatbot/chat');
 status.textContent='Connecting...';
 ws.onopen=()=>status.textContent='Online';
 ws.onclose=()=>status.textContent='Disconnected';
 ws.onmessage=e=>streamAI(JSON.parse(e.data));
}

function sendMsg(){
 const t=input.value.trim();
 if(!t) return;
 addMsg('user',t);
 input.value='';
 currentAI='';
 showTyping();
 ws.send(JSON.stringify({
  chatId:Date.now(),
  appId:'word-almost',
  systemPrompt:'You are SAMITECH AI Support assistant. Reply in clear human-like format.',
  message:t
 }));
}

function addMsg(type,text){
 const time=new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
 const div=document.createElement('div');
 div.className=`msg ${type}`;
 div.innerHTML=`${type==='ai'?`<img class=avatar src=https://cdn-icons-png.flaticon.com/512/4712/4712109.png>`:``}
  <div>
   <div class=bubble>${autoFormat(text)}</div>
   <div class=msg-tools>
    <span onclick=copyMsg(this)>Copy</span>
    <span onclick=editMsg(this)>Edit</span>
    <span onclick=deleteMsg(this)>Delete</span>
    <span>${time}</span>
   </div>
  </div>`;
 messages.appendChild(div);
 scroll(); saveChat();
 return div;
}

// ===== Auto-formatting (lists, bold, code) =====
function autoFormat(text){
 // code formatting: `inline` ‚Üí <code>inline</code>
 text=text.replace(/`([^`]+)`/g,'<code>$1</code>');
 // bold: **text** ‚Üí <b>text</b>
 text=text.replace(/\*\*([^*]+)\*\*/g,'<b>$1</b>');
 // unordered list: lines starting with - or * ‚Üí <ul><li>..</li></ul>
 let lines=text.split('\n');
 let formatted='', inList=false;
 lines.forEach(line=>{
   if(/^(\-|\*)\s+/.test(line)){
     if(!inList){formatted+='<ul>'; inList=true;}
     formatted+=`<li>${line.replace(/^(\-|\*)\s+/,'')}</li>`;
   } else {
     if(inList){formatted+='</ul>'; inList=false;}
     formatted+=line+'<br>';
   }
 });
 if(inList) formatted+='</ul>';
 return formatted;
}

// ===== Streaming AI =====
let currentAI='';
function streamAI(data){
 hideTyping();
 if(!aiMsgEl){
   aiMsgEl=addMsg('ai','');
   currentAI='';
 }
 if(data.message){
   currentAI+=data.message;
   aiMsgEl.querySelector('.bubble').innerHTML=autoFormat(currentAI);
   scroll();
 }
}

// ===== Typing indicator =====
let typingEl=null;
function showTyping(){
 typingEl=document.createElement('div');
 typingEl.className='msg ai';
 typingEl.innerHTML=`<img class=avatar src=https://cdn-icons-png.flaticon.com/512/4712/4712109.png>
 <div class=typing><div class=dot></div><div class=dot></div><div class=dot></div></div>`;
 messages.appendChild(typingEl);
 scroll();
}
function hideTyping(){typingEl?.remove(); typingEl=null;}

function scroll(){messages.scrollTop=messages.scrollHeight}

// ===== Message tools =====
function copyMsg(el){navigator.clipboard.writeText(el.closest('.msg').querySelector('.bubble').innerText);}
function editMsg(el){const b=el.closest('.msg').querySelector('.bubble');const t=prompt('Edit message',b.innerText); if(t) b.innerHTML=autoFormat(t); saveChat();}
function deleteMsg(el){el.closest('.msg').remove(); saveChat();}

// ===== Chat storage =====
function saveChat(){if(!allowSave) return; localStorage.setItem('chatLog',messages.innerHTML);}
function loadChat(){const d=localStorage.getItem('chatLog'); if(d) messages.innerHTML=d;}
</script>

</body>
</html>
